---
title: "React로 사고하기"
tags: [react, 컴포넌트]
---

## 들어가면서

리액트 사고하기라고 공식 홈페이지에 올라와 있지만, 솔직히 바닐라 자바스크립트로 개발할 때도 이러한 사고방식을 가지는 것이 좋은 방법 중 하나라고 생각합니다. 그만큼 리액트 사고하기는 리액트 공식 홈페이지에서 다루는 영역 중 가장 먼저 보고 익히면서 상태관리나 컴포넌트를 다루는 방법 등을 배우며 영역을 확장하는 것이 중요하다고 생각합니다. 이 글에서는 별도의 저만의 해석으로 정리하여 요약해보려고 하니 도움이 되었으면 합니다.

## 1. UI를 컴포넌트로 분해하기

UI를 작은 컴포넌트로 나누는 것은 재사용성과 유지보수성을 높이는 데 필수적입니다. 컴포넌트는 명확한 역할을 가지며 독립적으로 존재해야 합니다. 이는 단일 책임 원칙, SRP(Single Responsibility Principle)를 지키는 것입니다.

예를 들어, To-Do 리스트를 개발하는 경우 다음과 같이 컴포넌트를 분리할 수 있습니다:

```jsx
// 개별 To-Do 아이템 표시
const TodoItem = ({ item }) => {
  return <li>{item.text}</li>;
};

// 전체 To-Do 목록 표시
const ToDoList = ({ items }) => {
  return (
    <ul>
      {items.map((item) => (
        <TodoItem key={item.id} item={item} />
      ))}
    </ul>
  );
};
```

이처럼 분리하면 각 컴포넌트를 독립적으로 개발하고 유지보수할 수 있으며, 재사용성도 높아집니다. 그러나 TodoItem에 별다른 역할이 없다면 TodoList로 합쳐도 무관합니다. 필요 이상의 컴포넌트 분리는 오히려 복잡성을 증가시킬 수 있지만, 여기서는 각 컴포넌트에 기능이 추가된다고 가정합니다.

> 컴포넌트는 현재의 상황에 맞춰서 효율적으로 개발하는 것이 중요합니다. 특히 확정되지 않은 기획 문서를 예측해서 기능을 개발하는 경우 프로젝트의 복잡성과 요구사항이 변경되면 오히려 개발을 더 어렵게 만드는 요인이 됩니다. 이는 어디까지나 예제로서 작성합니다. 소프트웨어 개발 원칙 참고: [YAGNI](https://ko.wikipedia.org/wiki/YAGNI)

## 2. 정적 버전 만들기

정적 버전을 만드는 이유는 기능을 추가하기 전에 UI 구조를 정확하게 이해하기 위한 과정입니다. 이 단계에서는 데이터를 하드코딩하여 전체적인 레이아웃과 스타일을 완성하며, 컴포넌트 간의 관계와 데이터 흐름을 파악합니다.

```jsx
const items = [
  { id: 1, text: "Learn React" },
  { id: 2, text: "Build a To-Do App" },
];

const ToDoItem = ({ item }) => <li>{item.text}</li>;

const ToDoList = ({ items }) => (
  <ul>
    {items.map((item) => (
      <ToDoItem key={item.id} item={item} />
    ))}
  </ul>
);

const App = () => (
  <div>
    <h1>My To-Do List</h1>
    <ToDoList items={items} />
  </div>
);
```

## 3. 최소한의 State 식별하기

애플리케이션의 상태(state)를 관리하는 것은 성능 최적화와 코드의 복잡성을 줄이는 데 중요합니다. 상태는 변경될 수 있는 데이터로, 최소한으로 유지하는 것이 중요합니다. 예를 들어, 새로운 할 일을 추가하거나 기존 할 일을 완료로 업데이트하는 경우 상태를 적절히 관리해야 합니다. 상태는 변경되는 값을 의미하며, 변경되는 요소가 많으면 관리가 어려워지고 성능에도 영향을 줄 수 있습니다.

```jsx
const TodoList = () => {
  const [items, setItems] = useState([
    { id: 1, text: "리액트 배우기", completed: false },
    { id: 2, text: "점심먹기", completed: false },
  ]);

  const addItem = (text) => {
    const newItem = { id: items.length + 1, text, completed: false };
    setItems([...items, newItem]);
  };

  const toggleComplete = (id) => {
    setItems(
      items.map((item) =>
        item.id === id ? { ...item, completed: !item.completed } : item
      )
    );
  };

  return (
    <div>
      <h1>List</h1>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            <input
              type="checkbox"
              checked={item.completed}
              onChange={() => toggleComplete(item.id)}
            />
            {item.text}
          </li>
        ))}
      </ul>
      <button onClick={() => addItem("New Item")}>Add Item</button>
    </div>
  );
};
```

## 4. State 위치 결정하기

상태는 관련된 데이터가 공통으로 필요한 가장 가까운 부모 컴포넌트에 위치해야 합니다. 이를 통해 데이터의 흐름을 단순화하고 상태관리의 복잡성을 줄일 수 있습니다.

```jsx
const ToDoItem = ({ item, toggleComplete }) => (
  <li>
    <input
      type="checkbox"
      checked={item.completed}
      onChange={() => toggleComplete(item.id)}
    />
    {item.text}
  </li>
);

const ToDoList = ({ items, toggleComplete }) => (
  <ul>
    {items.map((item) => (
      <ToDoItem key={item.id} item={item} toggleComplete={toggleComplete} />
    ))}
  </ul>
);

const App = () => {
  const [items, setItems] = useState([
    { id: 1, text: "Learn React", completed: false },
    { id: 2, text: "Build a To-Do App", completed: false },
  ]);

  const toggleComplete = (id) => {
    setItems(
      items.map((item) =>
        item.id === id ? { ...item, completed: !item.completed } : item
      )
    );
  };

  const addItem = (text) => {
    const newItem = { id: items.length + 1, text, completed: false };
    setItems([...items, newItem]);
  };

  return (
    <div>
      <h1>My To-Do List</h1>
      <ToDoList items={items} toggleComplete={toggleComplete} />
      <button onClick={() => addItem("New Item")}>Add Item</button>
    </div>
  );
};
```

## 5. 데이터 흐름 추가하기

리액트의 단방향 데이터 흐름은 데이터의 예측 가능성을 높이고, 디버깅을 용이하게 합니다. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하여, 상위 레벨에서 하위 레벨로의 데이터 흐름을 명확히 합니다.

## 정리

공식 홈페이지에서의 제품 검색 애플리케이션을 간단히 요약하면 다음과 같습니다.

1. UI 컴포넌트 분해: 제품 목록, 검색창, 필터 옵션 등으로 분해
2. 정적 버전 만들기: 하드코딩된 데이터로 전체 레이아웃과 스타일 적용
3. 최소한의 State 식별/선별: 검색어와 필터링된 제품 목록을 상태로 정의
4. State 위치 결정: 최상의 부모 컴포넌트에 상태 위치
5. 데이터 흐름 추가: 부모에서 자식으로 데이터를 전달하여 필터링 로직 구현

이와 같은 접근은 프로젝트의 복잡성을 줄이고, 유지 보수를 쉽게 해줍니다.

## 결론

이처럼 리액트로 사고하기는 UI를 구성하고 상태를 관리하는 데 필수적인 접근 방식입니다. 이 개념을 이해하고 적용하면 더욱 효율적이고 견고한 리액트 애플리케이션을 만들 수 있습니다.

## 참고

- https://ko.legacy.reactjs.org/docs/thinking-in-react.html
- https://ko.react.dev/learn/thinking-in-react
